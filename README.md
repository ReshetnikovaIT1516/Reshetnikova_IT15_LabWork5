# Решетникова_IT15_Лабораторная работа 5
## Вариант 4.
## Задание 1
Шаблоны
### Задача 1
## Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
* Имеет числитель: целое число
* Имеет знаменатель: целое число
* Дробь может быть создана с указанием числителя и знаменателя
* Может вернуть строковое представление вида “числитель/знаменатель”
* Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
* Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
## Алгоритм решения
1. Определен FractionInterface с методами:
    - `getDecimalValue()` - получение вещественного значения
    - `setFraction()` - установка числителя и знаменателя

2. Класс Fraction включает:
    - Автоматическую нормализацию (знаменатель всегда положительный)
    - Проверку на нулевой знаменатель
    - Упрощение дробей через алгоритм Евклида (НОД)
    - Переопределение equals() и hashCode() для сравнения упрощенных дробей

3. Класс FractionCached реализует паттерн кэширования:
    - Сохраняет вычисленное значение в поле cache
    - Сбрасывает кэш при изменении дроби
    - Повторно использует кэшированное значение при повторных вызовах


## Тестирование
* Задача 1.1: Шаблоны. Дробь. 
* Введите количество дробей: 3 
* Введите 3 дробей (числитель и знаменатель):
* Дробь 1:
* Введите числитель: 1 
* Введите знаменатель: 5 
* Дробь добавлена: 1/5 
* Дробь 2:
* Введите числитель: 5 
* Введите знаменатель: 8 
* Дробь добавлена: 5/8 
* Дробь 3:
* Введите числитель: 10
* Введите знаменатель: 16 
* Дробь добавлена: 10/16 
* Обычные дроби 
* Дробь 1: 1/5 = 0.2 
* Дробь 2: 5/8 = 0.625 
* Дробь 3: 10/16 = 0.625
* Кэшированные дроби 
* Дробь 1: 1/5 = 0.2 
* Дробь 2: 5/8 = 0.625 
* Дробь 3: 10/16 = 0.625
* Сравнение дробей (каждая с каждой)
* Дробь 1 1/5 равняется Дроби 2 5/8: false 
* Дробь 1 1/5 равняется Дроби 3 10/16: false 
* Дробь 2 5/8 равняется Дроби 1 1/5: false 
* Дробь 2 5/8 равняется Дроби 3 10/16: true 
* Дробь 3 10/16 равняется Дроби 1 1/5: false 
* Дробь 3 10/16 равняется Дроби 2 5/8: true 
* Демонстрация hashCode()
* Дробь 1: 1/5 -> hashCode = 997 
* Дробь 2: 5/8 -> hashCode = 1124 
* Дробь 3: 10/16 -> hashCode = 1124 
* Изменение дроби с кэшем 
* Текущая дробь: 1/5 = 0.2 
* Введите новый числитель: 5 
* Введите новый знаменатель: 8
* После изменения: 5/8 = 0.625
* Повторное вычисление: 0.625
## Задание 2
Структурные шаблоны
### Задача 1
## Текст задачи
Количество мяуканий. Необходимо воспользоваться классом Кот и методом принимающим 
всех мяукающих из задачи 2.5.4. Необходимо таким образом передать кота в указанный 
метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его 
работы. Ниже показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку 
на кота в метод, после окончания его работы выводим количество мяуканий на экран. 
Кота изменять нельзя. 
25. Meowable m = ... //создаём кота 
26. Funs.meowsCare(m); 
27. System.out.println(...) //вывод: кот мяукал 5 раз
    Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
   * Имеет Имя (строка)
   * Для создания необходимо указать имя кота.
   * Может быть приведен к текстовой форме вида: “кот: Имя”
   * Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
   вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
   мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
   следующей сигнатурой:
   public void meow();
## Алгоритм решения
1. Создан интерфейс Meow с методом `meow()`

2. Класс Cat реализует:
    - Хранение имени кота
    - Вывод сообщения при мяуканье в формате "Имя: мяу!"
    - Строковое представление "Кот: Имя"

3. Класс CountMeowCat:
    - Содержит ссылку на оригинального кота
    - Считает количество вызовов метода meow()
    - Передает вызовы оригинальному коту

4. Метод обработки: Funs.meowsCare() вызывает мяуканье у переданных объектов

## Тестирование
* Задача 2.1: Структурные шаблоны. Количество мяуканий.
* Введите имя кота: Барсик
* Создан: Кот: Барсик
* Кот будет мяукать 3 раз:
* Барсик: мяу!
* Барсик: мяу!
* Барсик: мяу!
* Результат: Кот: Барсик помяукал 3 раз.

## Задание 3
Список
### Задача 1
## Текст задачи
Составить программу, которая удаляет из списка L все элементы E, если такие есть.
## Алгоритм решения
1. Создание списка и заполнение пользовательскими данными

2. Ввод элемента для удаления

3. Фильтрация элементов:
    - Создание нового списка для результата
    - Поэлементный обход исходного списка
    - Добавление в результат только тех элементов, которые не равны E

4. Сохранение исходных данных

5. Вывод результатов

## Тестирование
* Задача 3.1: Список. Удаление из списка.
* Введите количество элементов в списке: 5
* Введите 5 элементов:
* Элемент 1: **
* Элемент 2: qwerty
* Элемент 3: 12345
* Элемент 4: dsvz
* Элемент 5: **
* Полученный список: [**, qwerty, 12345, dsvz, **]
* Введите элемент E для удаления: **
* Исходный список: [**, qwerty, 12345, dsvz, **]
* Элемент для удаления: **
* Список после удаления: [qwerty, 12345, dsvz]

## Задание 4
Мап
### Задача 1
## Текст задачи
На вход программы подаются фамилии и имена учеников. Известно, что общее количество
учеников не превосходит 100. В первой строке вводится количество учеников, принимавших
участие в соревнованиях, N. Далее следуют N строк, имеющих следующий формат:
<Фамилия><Имя>
Здесь <Фамилия> – строка, состоящая не более чем из 20 символов; <Имя>– строка, состоящая не
более чем из 15 символов. При этом <Фамилия> и <Имя> разделены одним пробелом. Примеры
входных строк:
Иванова Мария
Петров Сергей
Требуется написать программу, которая формирует и печатает уникальный логин для каждого
ученика по следующему правилу: если фамилия встречается первый раз, то логин – это данная
фамилия, если фамилия встречается второй раз, то логин – это фамилия, в конец которой
приписывается число 2 и т.д. Например, для входной последовательности:
Иванова Мария
Петров Сергей
Бойцова Екатерина
Петров Иван
Иванова Наташа
будут сформированы следующие логины:
Иванова
Петров
Бойцова
Петров2
Иванова2

## Алгоритм решения
1. Загрузка списка учеников из файла с проверкой:
    - Существование файла
    - Максимальное количество учеников (не более 100)
    - Корректность формата данных

2. Использование HashMap для учета количества вхождений каждой фамилии

3. Генерация логинов:
    - Для первой встреченной фамилии - логин равен фамилии
    - Для повторяющихся фамилий - добавление порядкового номера
    - Сохранение порядка ввода через LinkedHashMap

4. Вывод исходных данных и сгенерированных логинов
## Тестирование
* Задача 4.1: Мап. ФИО учеников.
* Используется файл: students.txt
* Данные из файла:
* Иванова Мария
* Петров Сергей
* Бойцова Екатерина
* Петров Иван
* Иванова Наташа
* Сформированные логины:
* Иванова
* Петров
* Бойцова
* Петров2
* Иванова2



## Задание 5
Сет
### Задача 1
## Текст задачи
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все звонкие
согласные буквы, которые входят хотя бы в одно слово.
## Алгоритм решения
1. Загрузка текста из файла с проверкой его существования

2. Определение звонких согласных: 
   {'б', 'в', 'г', 'д', 'ж', 'з', 'й', 'л', 'м', 'н', 'р'}

3. Поиск согласных в тексте:
    - Приведение текста к нижнему регистру
    - Посимвольный анализ текста
    - Проверка принадлежности символа к русскому алфавиту
    - Проверка наличия в множестве звонких согласных

4. Сортировка результатов: Использование TreeSet для автоматической сортировки

5. Форматирование вывода: Вывод найденных согласных в алфавитном порядке
## Тестирование
* Задача 5.1: Сет. Звонкие согласные.
* Используется файл: set.txt
* Файл: set.txt
* Текст: "Проверка программы"
* Звонкие согласные буквы (в алфавитном порядке): в г м р


## Задание 6
Очередь
### Задача 5
## Текст задачи
Переписать элементы из очереди L1 в очередь L2 в обратном порядке.
## Алгоритм решения
1. Создание очередей

2. Использование стека:
    - Создание стека для временного хранения элементов
    - Перемещение всех элементов из L1 в стек (порядок обращается)

3. Формирование обратной очереди:
    - Извлечение элементов из стека в L2
    - Элементы попадают в L2 в обратном порядке относительно L1 
4. Очередь L1 остается неизмененной

## Тестирование
* Задача 6.5: Очередь. Обратный порядок.
* Введите количество элементов в очереди L1: 4
* Введите 4 элементов для очереди L1:
* Элемент 1: qwerty
* Элемент 2: 123
* Элемент 3: **
* Элемент 4: sadf
* Исходная очередь L1: Очередь: [qwerty, 123, **, sadf]
* Очередь L2 (обратный порядок): Очередь: [sadf, **, 123, qwerty]
* Очередь L1 (осталась без изменений): Очередь: [qwerty, 123, **, sadf]



## Задание 7
Стрим
### Задача 1
## Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
   * Координата Х: число.
   * Координата Y: число.
   * Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
   * Координата начала: Точка
   * Координата конца: Точка
   * Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
   линия представляет собой набор следующих характеристик:
   * Имеет массив Точек, через которые линия проходит.
   * Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
   результат приведения к строке Точки с номером N
## Алгоритм решения
1. Создание сущностей:
    - Point: хранение координат X, Y; строковое представление "{X;Y}"
    - Line: соединение двух точек; представление "Линия от {X1;Y1} до {X2;Y2}"
    - Polyline: последовательность точек; представление "Линия [T1,T2,...,TN]"

2. Обработка через Stream API:
    - `distinct()` - удаление точек с одинаковыми координатами
    - `map(p -> new Point(p.getX(), Math.abs(p.getY())))` - преобразование отрицательных Y
    - `sorted(Comparator.comparingDouble(Point::getX))` - сортировка по координате X
    - `collect(Collectors.toList())` - сбор в список для создания ломаной

3. Создание ломаной: Формирование Polyline из обработанного списка точек

## Тестирование
* Задача 7.1: Стрим. Точка, линия и ломанная
* Введите количество точек: 3
* Введите координаты точек:
* Точка 1:
* Введите координату X: 5
* Введите координату Y: -8
* Точка 1 добавлена: {5.0;-8.0}

* Точка 2:
* Введите координату X: 5
* Введите координату Y: 8
* Точка 2 добавлена: {5.0;8.0}

* Точка 3:
* Введите координату X: 9
* Введите координату Y: 0
* Точка 3 добавлена: {9.0;0.0}

* Исходные точки: [{5.0;-8.0}, {5.0;8.0}, {9.0;0.0}]
* Все отрицательные значения Y стали положительными 
* Результат - ломаная: Линия [{5.0;8.0}, {9.0;0.0}]





### Задача 2
## Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
## Алгоритм решения
1. Чтение и фильтрация данных:
    - Чтение всех строк из файла
    - `filter(line -> line.contains(":"))` - отсеивание строк без разделителя
    - `filter(entry -> !entry.getValue().isEmpty())` - удаление людей без номеров
    - `filter(entry -> entry.getValue().matches("\\d+"))` - проверка числового формата номера

2. Преобразование имен:
    - `map(entry -> name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase())`
    - Приведение к формату с первой заглавной буквой

3. Группировка по номерам:
    - `Collectors.groupingBy(Map.Entry::getValue, Collectors.mapping(Map.Entry::getKey, Collectors.toList()))`
    - Создание Map<Integer, List<String>> с именами, сгруппированными по номерам

4. Упорядочивание результатов по возрастанию номеров
## Тестирование
* Задача 7.2: Стрим. Имя и номер 
* Используется файл: names.txt 
* Исходные данные из файла:
* Вася:5 
* Петя:3 
* Аня:5 
* Катя:6 
* Настя:11 
* Женя:11 
* Результат группировки имен по номерам:
* [3: [Петя]]
* [5: [Вася, Аня]]
* [6: [Катя]]
* [11: [Настя, Женя]]